---
title: 算法练习
date: 2016-07-18 19:35:11
toc: true
tags:
  - 算法
categories:
  - 编程之美
---
问题分析:

- 画图 : 抽象问题形象化
- 举例 : 抽象问题具体化
- 分解 : 抽象问题简单化

<!--more-->

提高代码和算法能力的练习记录, 不仅仅只有Leetcode上的题, 还有`剑指offer`的读书笔记

## **LeetCode**

### **线性表**

**Array(数组)**

[26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

   - 双指针, 由于是排好序的数组, 设置一个初始化的index和遍历下标i

**String(字符串)**

[344. Reverse String](https://leetcode.com/problems/reverse-string/)
  代码实现 : [C++](https://github.com/Simshang/LeetcodeCpp/blob/master/LeetcodeCpp/ReverseString.cpp)
  - `双指针`实现
  - `栈`结构实现
  
[345. Reverse Vowels of a String](https://leetcode.com/problems/reverse-vowels-of-a-string/)
  代码实现 : 
  [C++](https://github.com/Simshang/LeetcodeCpp/blob/master/LeetcodeCpp/ReverseString.cpp) 
  [Java](https://github.com/Simshang/LeetCode/blob/master/src/ReverseString.java)
  
### **排序**

**起泡排序**

- 对于$n$个元素进行排序, 经过$k$趟扫描交换后, 最大的前$k$个元素必然就位, 与此同时, 待解决问题的有效规模将会缩减到$n-k$ 

**插入排序**

- 点击[动态演示][VisuAlgo:Sorting]查看

#####伪代码：

```
mark first element as sorted

for each unsorted element

  'extract' the element

  for i = lastSortedIndex to 0

    if currentSortedElement > extractedElement

      move sorted element to the right by 1

    else: insert extracted element
```

###### C++ 实现：

```C++
#include <iostream>

using namespace std;

void swapValue(int arr[],int index);
void input(int values[],int len);
void output(int values[],int len);
int main(void)
{
   int len = 5;
   int values[len];
   input(values,len);
   // output(values,len);
   //sorting
   for(int i=1;i<len;i++)
   {
       for(int j=i;j>0;j--)
       {
           if(values[j]<values[j-1])
            swapValue(values,j);
           else
            break;
       }
   }
   output(values,len);

}
//input:
void input(int values[],int len)
{
    for(int i=0;i<len;i++)
    {
        cout << "Enter values:"<< endl;
        cin >> values[i];
    }
}
//outPut:
void output(int values[],int len)
{
    for(int j=0;j<len;j++)
   {
       cout << values[j] <<endl;
   }

}

//swap:
void swapValue(int arr[],int index)
{
    int temp = arr[index];
    arr[index] = arr[index-1];
    arr[index-1] = temp;
}

```

[VisuAlgo:Sorting]:http://visualgo.net/sorting.html#

> **参考资料**

- [九章算法](http://www.jiuzhang.com/solutions/)

- [细语呢喃Leetcode算法题解](https://www.hrwhisper.me/leetcode-algorithm-solution/)

## **剑指offer**

### **效率优化**

- **优化菲波那切数列**

```
int fibonacci(int n) {
    if (n == 1)
    return 0;
    if (n == 2)
    return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}
```

- 通过递归调用树分析上面的代码的时间复杂度为$T(n)=T(n-1)+T(n-2)+O(1)= O(1.618 ^ n)$, 空间复杂度取决于递归的深度是$O(n)$, `总耗时:1007ms`

用`递归法`实现的代码包含着大量的重复计算, 如下图所示

![](\img\Leetcode\fibonacci.jpg)

我们在计算$F(5)$和$F(4)$的时候包含了大量的$F(3)$的重复计算, 所以我们采用`递推法`从$F(1)$开始计算, 代码如下

```c++
int fibonacci(int x){
    if (x == 1)
        return 0;
    if (x == 2)
        return 1;
    else
    {
        int p1 = 0;
        int p2 = 1;
        int result = 0;
        while (x > 2)
        {
            result = p1 + p2;
            p1 = p2;
            p2 = result;
            --x;
        }
    return result;
    }
}
```

- 时间复杂度是O(n)，空间复杂度是O(1), `总耗时 : 19 ms`