---
title: 编程珠玑
date: 2016-06-24 10:28:35
toc: true
tags:
  - Algorithm
categories:
  - 算法
---

查了相关资料说这是一本非常好的算法入门书, 于是买来学习一下, 记录学习过程中的一些扩展知识点以及关于课后习题的思考
> 参考书 : [编程珠玑（第2版•修订版）](https://book.douban.com/subject/26302533/)
<!--more-->

> 算法可视化工具[VisuAlgo](http://zh.visualgo.net/)

每一种算法都有自己的使用条件, 根据不同的问题具体分析, 比如对于输入比较小的问题, 是否可以将文件加载进内存排序而不是在磁盘上排序, 任何算法都是对于某一类问题的权衡, 必定要牺牲某种优势换取另一种优势, 同时应用背景还要了解应用背景, 因为不同的应用背景提出的性能需求不一样, 比如运行时间等指标

### **位排序**

**问题描述** : `空间<1MB, 时间<10s`

- 输入 : 在输入的$n=10^7$个`正整数`中, 每个数都`小于`$n$是并且`只出现一次`, 
- 输出 : `升序`排列的列表

**问题分析** :

- 在空间的限制下, 我们一次最多可以排序多少数据呢? 我们知道在基本数据类型的条件下表示数字n, 最好选择4个Byte的int类型(32bit), 因为我们希望用最少的字节数表示n($2^{32}>10^7$), 这样我们一次最多可排序$1MB/4Byte=250000$个数, 这样我们就需要$10^7/250000=40$次的IO操作, 对于加载到内存中的数据可以使用快速排序等排序方式进行排序, 这种方式的缺点很明显, 那么有没有更好的方法呢?

`1MB=10^6Byte=8*10^6bit<10^7`, 那么问题就是用大约800万个bit来标识1000万个数据(需要空间1.25MB)呢? 我们可以通过寻找稀疏位来实现, 但是假设现在有1.25MB空间了, 我们来看一下`位排序算法`
 
 1. 用位向量表示数据集合, 假如有正整数数据集$\\{2,4,5,7,8\\}$, 用位向量表示该数据集为:
 
   $$(01011011)_{bit}$$
   
   - 我们用`1Byte`的空间表示了上面的数据集, 也就是说在数据集中出现的数字在相应的位上标记为1, 否则标记为零, 这样我们用程序处理的时候自然也就排序了, 最后按顺序输出就可以了, 很精妙的算法!
   
 2. **注意**:减少程序的空间需求也会减少其运行时间, 因为减少空间需求意味着需要处理的数据量变小了, 那么处理时间也会相应的减少, 还有一个原因是我们可以将数据加载进内存而不是在磁盘上操作
 
> 代码实现见Github的Programming Pearls中的[bitsort.c](https://github.com/Simshang/Programming-Pearls/blob/master/Column%201/bitsort.c), 代码分析见`注释`
  测试结果:
  1. 位排序(`bitsort.c`):2260000ms
  2. C++的Set集合实现(`sortints.cpp`) : 31030000ms

位排序关键代码解析:

```
#define BITSPERWORD 32
#define SHIFT 5
#define MASK 0x1F
#define N 10000000
int a[1 + N/BITSPERWORD];
```

- 数组a所占的空间为1250004Byte, 也就是限制在1MB左右的内存, 共包含312501个元素

```
void set(int i) {        a[i>>SHIFT] |=  (1<<(i & MASK)); } //置1操作
void clr(int i) {        a[i>>SHIFT] &= ~(1<<(i & MASK)); } //置0操作
int  test(int i){ return a[i>>SHIFT] &   (1<<(i & MASK)); } //判断是否为1
```

- `1<<(i & MASK)` : 将1左移`(i & MASK)`位, 将二进制后面添加`(i & MASK)个0`实现左移操作

**(i & MASK)表示多少呢?** : [Stackoverflow](http://stackoverflow.com/questions/7218764/bit-mask-usage-in-the-program-below-from-programming-pearls)的相关问题

- i是int类型占用4Byte共32位, `MASK=0x1F`是两个十六进制共8位, 转化为2进制为$(00011111)_{2}$, 那么这个操作就是取i的低五位, 也就是说i的取值在[0,32]之间, 也就是说i最多左移32位, 这和int类型的大小是一致的, 即对于一个位操作是在一个整型元素内操作的, 这和我们定义的数组类型是相关的, 因为对于每一个元素来说实际操作的是32位, 其实这个操作本质上就是`i % 32`, 但是有一个条件`i & MASK and i % 32 are the same thing as long as you're sure i is not negative`, 因为我们最终想知道第i个数在a[]中某个元素的32位中的哪一位上, 所以要对32取余确定是32位的哪一位, `1<<(i & MASK)`便实现了在32位的二进制中置1的操作
 
**a[i>>SHIFT]确定了i在a[]中的哪个元素上**

- 我们知道对于二进制左移就是乘法运算, 右移就是除法运算, 那么`i>>SHIFT`表示将i右移5位, 也就是`i/32`便确定了i在a[]中的哪个元素上 

**a[i>>SHIFT] |=  (1<<(i & MASK));** : 数组元素置1操作(set)

`a[i>>SHIFT] = a[i>>SHIFT] | (1<<(i & MASK));`

- 我们知道了i在a[]中的具体元素(a[i>>SHIFT]), 也知道在该元素中的置1位置(`1<<(i & MASK)`), 通过或运算就将i的位置设置为1 
- `清零`和`判定`功能同理



### **随机数**

**问题描述** :

生成$[0,n-1]$之间的$k$个不同的乱序的随机整数? 假如生成一个1-10000000的随机数组，数组中的数字`不能重复`，但是`位置是随机的`

- 输入 : 两个整数$k$和$n$, 其中$k<n$
- 输出 : $k$个随机数

**问题分析** :

为了保证不重复, 最常见的思路是生成的随机数去数组里面判断一下存在与否, 但是这样效率太低了, 对于不能重复这一点, 我们知道数组的索引肯定是不重复的, 那么我们能否利用数组的索引来生成呢, 答案是肯定的

> 代码实现见 [gendata.cpp](https://github.com/Simshang/Programming-Pearls/blob/master/Column%201/gendata.cpp)

**关键代码分析**

```c++
int randint(int l, int r){
	return rand() % (r - l) + l;
}
for (int i = 0; i < N; i++)
	a[i] = i;
for (int i = 0; i < K; i++)
	swap(a[i], a[randint(i, N)]);
	printf("%d\n", a[i]);
```

- `randint()` : 生成了$[l,r]$之间的随机数

- 第一个`for`循环生成了一个下标序列, 保证不重复

- 第二个`for`循环交换了第i个元素和[i,N]之间的某一个元素, 也就是说第i个元素和该元素前面的某个元素进行随机交换, 因为都在同一个数组a[]内进行操作, 所以元素不会重复, 这样输出生成的k个不重复的值且在[0,n-1]之间 

### **取样问题**

在第十二章中详细讨论了随机取样这个问题: 

**问题描述**

- 输入$m$和$n$两个整数, $m<n$
- 输出是[0,n-1]范围内$m$个不重复的随机整数的`有序列表`

**问题分析**

在随机数的选择上, `不重复的条件`隐含着一个条件就是`只能在剩余的数中随机选择整数`, 也就是说这是一个`条件概率问题`, 即我们希望我们选择的随机数是等概率出现的, 举个例子来说:

$k=2,n=5$, 我们要在$0,1,2,3,4$之间选择两个数, 我们选择第一个数的时候概率是`1/5`

















