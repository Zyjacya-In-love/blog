---
title: 并发编程
date: 2016-08-22 12:23:40
tags:
  - Cpp
  - 并发编程
categories:
  - 笔记
---

在学习操作系统的进程和线程部分理解进程和线程的概念, 进程和线程具有并发性, 希望可以在代码层面学习并实践一下, 参考资料是forhappy的 [Cplusplus-Concurrency-In-Practice](https://github.com/forhappy/Cplusplus-Concurrency-In-Practice/blob/master/README.md)

<!--more-->
### 环境

1. 下载 [x86_64-w64-mingw32-gcc-4.8-stdthread-win64_rubenvb.7z](http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/rubenvb/gcc-4.8-experimental-stdthread/)编译器并在`Codeblocks`中配置

2. 具体配置见 [stackoverflow : C++11, GCC 4.8.1,Code::Blocks, threading, what a head ache](http://stackoverflow.com/questions/18951454/c11-gcc-4-8-1-codeblocks-threading-what-a-head-ache)

测试代码:

```
#include <stdio.h>
#include <stdlib.h>

#include <chrono>    // std::chrono::seconds
#include <iostream>  // std::cout
#include <thread>    // std::thread, std::this_thread::sleep_for

void thread_task(int n) {
    std::this_thread::sleep_for(std::chrono::seconds(n));
    std::cout << "hello thread "
        << std::this_thread::get_id()
        << " paused " << n << " seconds" << std::endl;
}

int main(int argc, const char *argv[])
{
    std::thread threads[5];
    std::cout << "Spawning 5 threads...\n";
    for (int i = 0; i < 5; i++) {
        threads[i] = std::thread(thread_task, i + 1);
    }
    std::cout << "Done spawning threads! Now wait for them to join\n";
    for (auto& t: threads) {
        t.join();
    }
    std::cout << "All threads joined.\n";

    return EXIT_SUCCESS;
}
```

### **并发与并行**

- 并发是一个处理器同时处理多个任务，而并行多个处理器或者是多核的处理器同时处理多个不同的任务
- 并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生

### **程序的原子性**

A想要从自己的帐户中转1000块钱到B的帐户里。那个从A开始转帐，到转帐结束的这一个过程，称之为一个事务。在这个事务里，要做如下操作：

1. 从A的帐户中减去1000块钱。如果A的帐户原来有3000块钱，现在就变成2000块钱了。

2. 在B的帐户里加1000块钱。如果B的帐户如果原来有2000块钱，现在则变成3000块钱了。

如果在A的帐户已经减去了1000块钱的时候，忽然发生了意外，比如停电什么的，导致转帐事务意外终止了，而此时B的帐户里还没有增加1000块钱。那么，我们称这个操作失败了，要进行回滚。回滚就是回到事务开始之前的状态，也就是回到A的帐户还没减1000块的状态，B的帐户的原来的状态。此时A的帐户仍然有3000块，B的帐户仍然有2000块。

我们把这种要么一起成功（A帐户成功减少1000，同时B帐户成功增加1000），要么一起失败（A帐户回到原来状态，B帐户也回到原来状态）的操作叫原子性操作, 也就是在操作过程中不能被打断, 如果把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行, 这种特性就叫原子性